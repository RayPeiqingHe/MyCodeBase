#!/usr/bin/python
# -*- coding: utf-8 -*-

# strategy.py

from __future__ import print_function

try:
    import Queue as queue
except ImportError:
    import queue

from event import SignalEvent
from data import SecurityMasterDataHandler
from backtest import Backtest
from execution import *
from portfolio import Portfolio
from order import *


class StrategyMetaClass(ABCMeta):
    """
    Custom meta class to keep track of all strategies

    """

    strategy_id_map = {}
    strategy_cnt = 0

    def __init__(cls, name, bases, attrs):
        if "__init__" in cls.__dict__:

            cls.strategy_cnt += 1

            cls.strategy_id_map[str(cls)] = cls.strategy_cnt

        super(StrategyMetaClass, cls).__init__(name, bases, attrs)


class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars
    (OHLCV) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to where the data came from,
    since it obtains the bar tuples from a queue object.

    This based class os to be inherited by the subsequent mean-revert
    strategy and machine-learning forecasting strategy
    """

    __metaclass__ = StrategyMetaClass

    @abstractmethod
    def calculate_signals(self, event):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")

    @property
    def strategy_id(self):

        cls = type(self)

        return cls.strategy_id_map[str(cls)]


class BuyAndHoldStrategy(Strategy):
    """
    The simply buy and hold strategy. Used as a bench market to
    Compare the performance of other strategies

    """

    def __init__(self, bars, events):
        """
        Initialises the Moving Average Cross Strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        short_window - The short moving average lookback.
        long_window - The long moving average lookback.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        self.symbol_list_bought = dict([(s, False) for s in self.symbol_list])

    def calculate_signals(self, event):
        """
        Dummy buy and hold strategy

        :param event:
        :return:
        """

        if event.type == 'MARKET':
            symbols_to_buy = []

            for s in self.symbol_list:
                if not self.symbol_list_bought[s]:
                    self.symbol_list_bought[s] = True

                    bar_date = self.bars.get_latest_bar_datetime(s)

                    print("LONG: {0} {1}".format(bar_date, s))

                    dt = datetime.datetime.utcnow()

                    symbols_to_buy.append(s)

            if len(symbols_to_buy) > 0:
                signal = SignalEvent(self.strategy_id, symbols_to_buy, dt, 'LONG', 1.0)
                self.events.put(signal)


if __name__ == '__main__':

    symbol_list = ['AAPL', 'GOOG']

    initial_capital = 100000.0
    heartbeat = 0.0

    data_handler = SecurityMasterDataHandler(symbol_list)

    start_date = data_handler.start_dt

    order_method = NaiveOrder

    order_method = EquityWeightOrder

    backtest = Backtest(
        symbol_list, initial_capital, heartbeat,
        start_date, data_handler, SimulatedExecutionHandlerWithCommision,
        Portfolio, BuyAndHoldStrategy, order_method
    )
    backtest.simulate_trading()